import fs from "node:fs/promises";
import path from "node:path";

export async function pathExists(p) {
  try {
    await fs.access(p);
    return true;
  } catch {
    return false;
  }
}

export async function ensureDir(dirPath) {
  await fs.mkdir(dirPath, { recursive: true });
}

export async function readText(filePath) {
  return await fs.readFile(filePath, "utf8");
}

export async function writeText(filePath, content) {
  await ensureDir(path.dirname(filePath));
  await fs.writeFile(filePath, content, "utf8");
}

export async function writeIfAbsent(filePath, content, report) {
  if (await pathExists(filePath)) {
    report?.skipped?.push(filePath);
    return { wrote: false, reason: "exists" };
  }
  await writeText(filePath, content);
  report?.added?.push(filePath);
  return { wrote: true };
}

const GENERATED_MARK = "@generated by sdd-lite";

export function withGeneratedHeader(body, { fileLabel } = {}) {
  const label = fileLabel ? ` (${fileLabel})` : "";
  return `// ${GENERATED_MARK}${label}\n${body}`;
}

export async function writeGenerated(filePath, content, report) {
  const next = withGeneratedHeader(content);
  if (!(await pathExists(filePath))) {
    await writeText(filePath, next);
    report?.added?.push(filePath);
    return { wrote: true, kind: "add" };
  }

  const prev = await readText(filePath);
  if (!prev.startsWith(`// ${GENERATED_MARK}`)) {
    const examplePath = `${filePath}.example`;
    if (!(await pathExists(examplePath))) {
      await writeText(examplePath, next);
      report?.added?.push(examplePath);
      report?.notes?.push(`Existing file kept, wrote example: ${examplePath}`);
      return { wrote: true, kind: "example" };
    }
    report?.skipped?.push(filePath);
    report?.notes?.push(`Existing file kept, example already exists: ${examplePath}`);
    return { wrote: false, kind: "skip" };
  }

  if (prev === next) {
    report?.skipped?.push(filePath);
    return { wrote: false, kind: "skip" };
  }
  await writeText(filePath, next);
  report?.modified?.push(filePath);
  return { wrote: true, kind: "mod" };
}

export async function patchTextFile(filePath, patcher, report) {
  if (!(await pathExists(filePath))) {
    report?.notes?.push(`Patch skipped, file missing: ${filePath}`);
    return { patched: false, reason: "missing" };
  }
  const prev = await readText(filePath);
  const next = patcher(prev);
  if (next == null || next === prev) {
    report?.skipped?.push(filePath);
    return { patched: false, reason: "no-change" };
  }
  await writeText(filePath, next);
  report?.modified?.push(filePath);
  return { patched: true };
}

export async function walkFiles(rootDir, { ignoreDirs } = {}) {
  /** @type {string[]} */
  const results = [];
  const ignores = new Set(ignoreDirs || ["node_modules", ".git", "dist"]);

  async function walk(dir) {
    const entries = await fs.readdir(dir, { withFileTypes: true });
    for (const ent of entries) {
      const full = path.join(dir, ent.name);
      if (ent.isDirectory()) {
        if (ignores.has(ent.name)) continue;
        await walk(full);
        continue;
      }
      if (ent.isFile()) results.push(full);
    }
  }

  if (await pathExists(rootDir)) await walk(rootDir);
  return results;
}

export function toPosixPath(p) {
  return p.split(path.sep).join("/");
}

